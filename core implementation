# -*- coding: utf-8 -*-
"""LRCN_architecture_for_workout_detection_v3.0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10dXc96jX1x8bzPjQBPEpzxiAWrjXT1ls
"""



"""# MOVEMENTOR

In the world of fitness, doing exercises with the right form is crucial. But many people struggle with this, leading to injuries and less effective workouts. To fix this, we're exploring a new way of using technology. We're combining two powerful tools, Convolutional Neural Networks (CNNs) and Long Short-Term Memory (LSTM) networks, in a cool hybrid model called LRCN.

## Import Libraries
"""

import IPython
from google.colab import output

display(IPython.display.Javascript('''
function ClickConnect(){
  btn = document.querySelector("colab-connect-button")
  if (btn != null){
    console.log("Click colab-connect-button");
    btn.click()
    }

  btn = document.getElementById('ok')
  if (btn != null){
    console.log("Click reconnect");
    btn.click()
    }
  }

setInterval(ClickConnect,60000)
'''))

# Commented out IPython magic to ensure Python compatibility.
# Import the required libraries.
import os
import cv2
import math
import random
import numpy as np
import datetime as dt
import tensorflow as tf
from collections import deque
import matplotlib.pyplot as plt


from moviepy.editor import *
# %matplotlib inline

from sklearn.model_selection import train_test_split

from tensorflow.keras.layers import *
from tensorflow.keras.models import Sequential
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.utils import plot_model

"""setting a seed to get consistent results on excecutions and for control randomness"""

custom_seed = 25
np.random.seed(custom_seed)
random.seed(custom_seed)
tf.random.set_seed(custom_seed)

from google.colab import drive
drive.mount('/content/drive')

"""## visualize the data with labels

for this project we are using Kaggle workout dataset with 22 different workouts. for visualization we will pick 10 random categories from the dataset and a random video from each selected category and will visualize the fist frame of the selected videos with their associated labels written. this is for visualize a subset of the dataset.
"""

# Create a Matplotlib figure and specify the size of the figure.
plt.figure(figsize = (20, 20))

# Get the names of all classes/categories in UCF50.
all_classes_names = os.listdir('/content/drive/MyDrive/workout Datasets/kaggle/KaggleWorkouts')

# Generate a list of 10 random values. The values will be between 0-22,
# where 22 is the total number of class in the dataset.
random_range = random.sample(range(len(all_classes_names)), 10)

# Iterating through all the generated random values.
for counter, random_index in enumerate(random_range, 1):

    # Retrieve a Class Name using the Random Index.
    selected_class_Name = all_classes_names[random_index]

    # Retrieve the list of all the video files present in the randomly selected Class Directory.
    video_files_names_list = os.listdir(f'/content/drive/MyDrive/workout Datasets/kaggle/KaggleWorkouts/{selected_class_Name}')

    # Randomly select a video file from the list retrieved from the randomly selected Class Directory.
    selected_video_file_name = random.choice(video_files_names_list)

    # Initialize a VideoCapture object to read from the video File.
    video_reader = cv2.VideoCapture(f'/content/drive/MyDrive/workout Datasets/kaggle/KaggleWorkouts/{selected_class_Name}/{selected_video_file_name}')

    # Read the first frame of the video file.
    _, bgr_frame = video_reader.read()


    # Release the VideoCapture object.
    video_reader.release()

    # Convert the frame from BGR into RGB format.
    rgb_frame = cv2.cvtColor(bgr_frame, cv2.COLOR_BGR2RGB)

    # Write the class name on the video frame.
    cv2.putText(rgb_frame, selected_class_Name, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)

    # Display the frame.
    plt.subplot(5, 4, counter);plt.imshow(rgb_frame);plt.axis('off')

!ls "/content/drive/MyDrive/workout Datasets/kaggle/KaggleWorkouts"

"""## data preprocessing


"""

# Specify the height and width to which each video frame will be resized in our dataset.
IMAGE_HEIGHT , IMAGE_WIDTH = 64, 64

# Specify the number of frames of a video that will be fed to the model as one sequence.
SEQUENCE_LENGTH = 50

# Specify the directory containing the UCF50 dataset.
DATASET_DIR = "/content/drive/MyDrive/workout Datasets/kaggle/KaggleWorkouts"

# Specify the list containing the names of the classes used for training. Feel free to choose any set of classes.
CLASSES_LIST = ["shoulder press", "lat pulldown", "squat", "tricep Pushdown" ]

"""## fuction to extract, resize and normalize data"""

def frames_extraction(video_path):
    '''
    This function will extract the required frames from a video after resizing and normalizing them.
    Args:
        video_path: The path of the video in the disk, whose frames are to be extracted.
    Returns:
        frames_list: A list containing the resized and normalized frames of the video.
    '''

    # Declare a list to store video frames.
    frames_list = []

    # Read the Video File using the VideoCapture object.
    video_reader = cv2.VideoCapture(video_path)

    # Get the total number of frames in the video.
    video_frames_count = int(video_reader.get(cv2.CAP_PROP_FRAME_COUNT))

    # Calculate the interval after which frames will be added to the list.
    skip_frames_window = max(int(video_frames_count/SEQUENCE_LENGTH), 1)

    # Iterate through the Video Frames.
    for frame_counter in range(SEQUENCE_LENGTH):

        # Calculate the frame index to read
        frame_index = frame_counter * skip_frames_window

        # Set the current frame position of the video.
        video_reader.set(cv2.CAP_PROP_POS_FRAMES, frame_index)

        # Reading the frame from the video.
        success, frame = video_reader.read()

        # If the frame is not successfully read, duplicate the first frame sequentially again.
        if not success:
            # If frames are already extracted, duplicate the first frame sequentially again.
            if frames_list:
                duplicate_frame = frames_list[frame_counter % len(frames_list)].copy()  # Duplicate the frame from frames_list
            # Otherwise, return None indicating failure
            else:
                return None
        else:
            # Resize the Frame to fixed height and width.
            resized_frame = cv2.resize(frame, (IMAGE_HEIGHT, IMAGE_WIDTH))

            # Normalize the resized frame by dividing it with 255 so that each pixel value then lies between 0 and 1
            normalized_frame = resized_frame / 255

            # Append the normalized frame into the frames list
            frames_list.append(normalized_frame)

    # Release the VideoCapture object.
    video_reader.release()

    # Return the frames list.
    return frames_list

video_path = "/content/drive/MyDrive/workout Datasets/kaggle/KaggleWorkouts/bench press/bench press_19.mp4"
frames_list = frames_extraction(video_path)

# Display first few frames len(frames_list)
num_frames_to_display = len(frames_list)
for i in range(num_frames_to_display):
    plt.imshow(frames_list[i])
    plt.title(f"Frame {i+1}")
    plt.show()

"""## function for create the dataset"""

def create_dataset():
    '''
    This function will extract the data of the selected classes and create the required dataset.
    Returns:
        features:          A list containing the extracted frames of the videos.
        labels:            A list containing the indexes of the classes associated with the videos.
        video_files_paths: A list containing the paths of the videos in the disk.
    '''

    # Declared Empty Lists to store the features, labels and video file path values.
    features = []
    labels = []
    video_files_paths = []

    # Iterating through all the classes mentioned in the classes list
    for class_index, class_name in enumerate(CLASSES_LIST):

        # Display the name of the class whose data is being extracted.
        print(f'Extracting Data of Class: {class_name}')

        # Get the list of video files present in the specific class name directory.
        files_list = os.listdir(os.path.join(DATASET_DIR, class_name))

        # Iterate through all the files present in the files list.
        for file_name in files_list:

            # Get the complete video path.
            video_file_path = os.path.join(DATASET_DIR, class_name, file_name)

            # Extract the frames of the video file.
            frames = frames_extraction(video_file_path)

            # Check if the extracted frames are equal to the SEQUENCE_LENGTH specified above.
            # So ignore the vides having frames less than the SEQUENCE_LENGTH.
            if len(frames) == SEQUENCE_LENGTH:

                # Append the data to their repective lists.
                features.append(frames)
                labels.append(class_index)
                video_files_paths.append(video_file_path)

    # Converting the list to numpy arrays
    features = np.asarray(features)
    labels = np.array(labels)

    # Return the frames, class index, and video file path.
    return features, labels, video_files_paths

"""using create_dataset() function to extract the data of the sected classes to create the dataset"""

# Create the dataset.
features, labels, video_files_paths = create_dataset()

# Using Keras's to_categorical method to convert labels into one-hot-encoded vectors
one_hot_encoded_labels = to_categorical(labels)

"""## split the dataset"""

# Split the Data into Train ( 75% ) and Test Set ( 25% ).
features_train, features_test, labels_train, labels_test = train_test_split(features, one_hot_encoded_labels,
                                                                            test_size = 0.25, shuffle = True,
                                                                            random_state = custom_seed)

"""## Implimenting the LRCN Model"""

from keras.models import Model

def create_LRCN_model(input_shape, num_classes):
    '''
    This function constructs a custom LRCN model using the Functional API.
    Args:
        input_shape: Tuple specifying the shape of the input data (sequence_length, image_height, image_width, num_channels).
        num_classes: Number of output classes.
    Returns:
        model: The constructed LRCN model.
    '''
    # Define the input layer
    input_layer = Input(shape=input_shape)

    # Define the convolutional layers (applied to each frame in the sequence)
    conv_layer1 = TimeDistributed(Conv2D(16, (3, 3), padding='same', activation='relu'))(input_layer)
    pool_layer1 = TimeDistributed(MaxPooling2D((4, 4)))(conv_layer1)
    dropout_layer1 = TimeDistributed(Dropout(0.25))(pool_layer1)

    conv_layer2 = TimeDistributed(Conv2D(32, (3, 3), padding='same', activation='relu'))(dropout_layer1)
    pool_layer2 = TimeDistributed(MaxPooling2D((4, 4)))(conv_layer2)
    dropout_layer2 = TimeDistributed(Dropout(0.25))(pool_layer2)

    conv_layer3 = TimeDistributed(Conv2D(64, (3, 3), padding='same', activation='relu'))(dropout_layer2)
    pool_layer3 = TimeDistributed(MaxPooling2D((2, 2)))(conv_layer3)
    dropout_layer3 = TimeDistributed(Dropout(0.25))(pool_layer3)

    conv_layer4 = TimeDistributed(Conv2D(64, (3, 3), padding='same', activation='relu'))(dropout_layer3)
    pool_layer4 = TimeDistributed(MaxPooling2D((2, 2)))(conv_layer4)

    # Flatten the output from convolutional layers
    flatten_layer = TimeDistributed(Flatten())(pool_layer4)

    # Apply LSTM layer to process the temporal sequence
    lstm_layer = LSTM(32)(flatten_layer)

    # Output layer with softmax activation
    output_layer = Dense(num_classes, activation='softmax')(lstm_layer)

    # Construct the model
    model = Model(inputs=input_layer, outputs=output_layer)

    # Display model summary
    model.summary()

    return model

input_shape = (SEQUENCE_LENGTH, IMAGE_HEIGHT, IMAGE_WIDTH, 3)
num_classes = len(CLASSES_LIST)

# Construct the required LRCN model.
LRCN_model = create_LRCN_model(input_shape, num_classes)

# Display the success message.
print("Model Created Successfully!")

# Plot the structure of the contructed LRCN model.
plot_model(LRCN_model, to_file = 'LRCN_model_structure_plot.png', show_shapes = True, show_layer_names = True)

# Create an Instance of Early Stopping Callback.
early_stopping_callback = EarlyStopping(monitor = 'val_loss', patience = 15, mode = 'min', restore_best_weights = True)

# Compile the model and specify loss function, optimizer and metrics to the model.
LRCN_model.compile(loss = 'categorical_crossentropy', optimizer = 'Adam', metrics = ["accuracy"])

# Start training the model.
LRCN_model_training_history = LRCN_model.fit(x = features_train, y = labels_train, epochs = 70, batch_size = 4 ,
                                             shuffle = True, validation_split = 0.2, callbacks = [early_stopping_callback])

# # Compile the model and specify loss function, optimizer, and metrics to the model.
# LRCN_model.compile(loss='categorical_crossentropy', optimizer='Adam', metrics=["accuracy"])

# # Start training the model without EarlyStopping callback.
# LRCN_model_training_history = LRCN_model.fit(x=features_train, y=labels_train, epochs=70, batch_size=4,
#                                              shuffle=True, validation_split=0.2)

# Evaluate the trained model.
model_evaluation_history = LRCN_model.evaluate(features_test, labels_test)

# Get the loss and accuracy from model_evaluation_history.
model_evaluation_loss, model_evaluation_accuracy = model_evaluation_history


# Define a useful name for our model to make it easy for us while navigating through multiple saved models.
# model_file_name = f'Version 01.03 LRCN_model___Date_Time_{current_date_time_string}___Loss_{model_evaluation_loss}___Accuracy_{model_evaluation_accuracy}.h5'
model_file_name = f'Version 02.02 LRCN_model___Loss_{model_evaluation_loss}___Accuracy_{model_evaluation_accuracy}.h5'

# Save the Model.
LRCN_model.save(model_file_name)

def plot_metric(model_training_history, metric_name_1, metric_name_2, plot_name):
    '''
    This function will plot the metrics passed to it in a graph.
    Args:
        model_training_history: A history object containing a record of training and validation
                                loss values and metrics values at successive epochs
        metric_name_1:          The name of the first metric that needs to be plotted in the graph.
        metric_name_2:          The name of the second metric that needs to be plotted in the graph.
        plot_name:              The title of the graph.
    '''

    # Get metric values using metric names as identifiers.
    metric_value_1 = LRCN_model_training_history.history[metric_name_1]
    metric_value_2 = LRCN_model_training_history.history[metric_name_2]

    # Construct a range object which will be used as x-axis (horizontal plane) of the graph.
    epochs = range(len(metric_value_1))

    # Plot the Graph.
    plt.plot(epochs, metric_value_1, 'blue', label = metric_name_1)
    plt.plot(epochs, metric_value_2, 'red', label = metric_name_2)

    # Add title to the plot.
    plt.title(str(plot_name))

    # Add legend to the plot.
    plt.legend()

# Visualize the training and validation loss metrices.
plot_metric(LRCN_model_training_history, 'loss', 'val_loss', 'Total Loss vs Total Validation Loss')

# Visualize the training and validation accuracy metrices.
plot_metric(LRCN_model_training_history, 'accuracy', 'val_accuracy', 'Total Accuracy vs Total Validation Accuracy')

